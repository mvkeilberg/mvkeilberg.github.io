{{ define "content" }}

<style>
    .table-responsive {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        background: #fff;
        border-radius: 12px;
        box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
        margin: 1rem 0;
    }

    /* Wichtig: Tabelle darf breiter als der Container werden */
    .table-responsive>table {
        width: max-content;
        min-width: 100%;
    }

    /* Mehr Abstand */
    .table td,
    .table th {
        padding-left: 16px;
        padding-right: 16px;
    }
</style>

<div class="container pt-4 pb-5" id="silvester">
    <div class="row text-center">
        <div class="col-lg-10 mx-auto">
            <h1 class="fw-bold text-primary">{{ .Title }}</h1>
            <p class="lead text-muted">{{ .Params.description }}</p>
        </div>
    </div>

    <div class="row mt-5 align-items-start">
        <div class="col-lg-8">
            <div class="rounded-3 shadow-sm border" style="height: 65vh; min-height: 420px; overflow: hidden;">
                <div id="map" style="height: 100%; width: 100%;"></div>
            </div>
            <p class="text-muted mt-2 mb-0">Standortdaten werden live aktualisiert.</p>
        </div>

        <div class="col-lg-4 pt-4 pt-lg-0">
            <div class="p-3 rounded-3 shadow-sm border bg-white">
                <h3 class="fw-semibold text-secondary mb-2">Gruppen</h3>
                <div id="groupList" class="text-muted small">Keine aktuellen Daten verfügbar. Warte auf Daten …</div>
            </div>
        </div>
    </div>

    <div class="container pt-5">
        {{- .Content | safeHTML -}}
    </div>
</div>
</div>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

<script>
    const API_URL = {{ .Params.location_api | default "/update" | printf "%q" | safeJS }};
    const POLL_MS = 5000;

    const CLUBHOUSE = [49.977298266144714, 9.255421284031236];
    const CLUBHOUSE_ZOOM = 15;

    const map = L.map("map").setView(CLUBHOUSE, CLUBHOUSE_ZOOM);

    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
        attribution: '&copy; OpenStreetMap-Mitwirkende'
    }).addTo(map);

    // groupName -> Leaflet marker
    const markers = new Map();

    function escapeHtml(str) {
        return String(str || "")
            .replaceAll("&", "&amp;")
            .replaceAll("<", "&lt;")
            .replaceAll(">", "&gt;")
            .replaceAll('"', "&quot;")
            .replaceAll("'", "&#039;");
    }

    function fmtTime(tsSeconds) {
        try {
            const d = new Date(tsSeconds * 1000);
            return d.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
        } catch {
            return "";
        }
    }

    // Farbpalette (Icons existieren im pointhi/leaflet-color-markers Repo)
    const COLOR_ORDER = ["red", "blue", "green", "orange", "violet", "yellow", "grey", "black"];
    const ICON_BASE = "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/";

    // Cache: groupName -> Icon
    const iconCache = new Map();

    function hashStringToInt(s) {
        let h = 0;
        for (let i = 0; i < s.length; i++) {
            h = ((h << 5) - h) + s.charCodeAt(i);
            h |= 0;
        }
        return Math.abs(h);
    }

    function colorForGroup(name) {
        const idx = hashStringToInt(name) % COLOR_ORDER.length;
        return COLOR_ORDER[idx];
    }

    function getIconForGroup(name) {
        if (iconCache.has(name)) return iconCache.get(name);

        const color = colorForGroup(name);
        const icon = new L.Icon({
            iconUrl: `${ICON_BASE}marker-icon-${color}.png`,
            shadowUrl: "https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png",
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
        });

        iconCache.set(name, icon);
        return icon;
    }

    function updateSidebar(groupsObj) {
        const el = document.getElementById("groupList");
        const names = Object.keys(groupsObj || {}).sort((a, b) => a.localeCompare(b, "de"));

        if (names.length === 0) {
            el.innerHTML = "Keine aktiven Gruppen gefunden.";
            return;
        }

        el.innerHTML = names.map(name => {
            const g = groupsObj[name] || {};
            const t = g.ts ? fmtTime(g.ts) : "";
            const user = g.user ? `, ${g.user}` : "";
            const color = colorForGroup(name);

            return `
                <div class="d-flex justify-content-between align-items-baseline py-1">
                    <span class="d-flex align-items-center gap-2">
                        <span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:${color};"></span>
                        <span>
                            <span class="fw-semibold text-primary">${escapeHtml(name)}</span>
                            <span class="text-muted">${escapeHtml(user)}</span>
                        </span>
                    </span>
                    <span class="text-muted">${escapeHtml(t)}</span>
                </div>
            `;
        }).join("");
    }

    // Einmalig fitBounds, sobald mindestens 2 Gruppen aktiv sind
    let hasAutoFit = false;

    function autoFitIfNeeded(groupLatLngs) {
        if (groupLatLngs.length < 2) {
            hasAutoFit = false;
            return;
        }
        if (hasAutoFit) return;

        const bounds = L.latLngBounds(groupLatLngs);
        map.fitBounds(bounds.pad(0.25));
        hasAutoFit = true;
    }

    async function fetchAndRender() {
        try {
            const res = await fetch(API_URL, { cache: "no-store" });

            if (res.status === 204) {
                updateSidebar({});
                for (const [name, m] of markers.entries()) {
                    map.removeLayer(m);
                    markers.delete(name);
                }
                hasAutoFit = false;
                return;
            }

            if (!res.ok) throw new Error("HTTP " + res.status);

            const data = await res.json();
            const groups = (data && data.groups) ? data.groups : {};

            updateSidebar(groups);

            const activeNames = new Set(Object.keys(groups));
            const latlngs = [];

            for (const name of Object.keys(groups)) {
                const g = groups[name] || {};
                const lat = Number(g.lat);
                const lon = Number(g.lon);
                if (!Number.isFinite(lat) || !Number.isFinite(lon)) continue;

                latlngs.push(L.latLng(lat, lon));

                const timeStr = g.ts ? fmtTime(g.ts) : "";
                const userStr = g.user ? g.user : "";

                const popupHtml = `
                    <div>
                        <div class="fw-semibold">${escapeHtml(name)}</div>
                        <div class="text-muted small">${lat.toFixed(6)}, ${lon.toFixed(6)}</div>
                        <div class="text-muted small">${escapeHtml(userStr)}${timeStr ? " • " + escapeHtml(timeStr) : ""}</div>
                        ${g.osm ? `<div class="mt-2"><a href="${g.osm}" target="_blank" rel="noopener">OpenStreetMap öffnen</a></div>` : ""}
                    </div>
                `;

                const icon = getIconForGroup(name);
                const pos = [lat, lon];

                if (!markers.has(name)) {
                    const m = L.marker(pos, { icon }).addTo(map);
                    m.bindPopup(popupHtml);
                    markers.set(name, m);
                } else {
                    const m = markers.get(name);
                    m.setLatLng(pos);
                    m.setIcon(icon);
                    m.setPopupContent(popupHtml);
                }
            }

            for (const [name, m] of markers.entries()) {
                if (!activeNames.has(name)) {
                    map.removeLayer(m);
                    markers.delete(name);
                }
            }

            autoFitIfNeeded(latlngs);

        } catch (e) {
            console.log("fetchAndRender error:", e);
        }
    }

    fetchAndRender();
    setInterval(fetchAndRender, POLL_MS);
</script>

<script>
    (function () {
        const tables = document.querySelectorAll(".container table, main table, article table");

        for (const table of tables) {
            // Bootstrap Klassen auf die Tabelle
            table.classList.add("table", "table-hover", "align-middle");

            // Optional: kompakter
            table.classList.add("table-sm");

            // Optional: damit es auf Mobil nicht umbricht, sondern scrollt
            // (Bootstrap table-responsive scrollt zwar, aber nowrap macht es ruhiger)
            for (const cell of table.querySelectorAll("th, td")) {
                cell.classList.add("text-nowrap");
            }

            // In table-responsive wrappen für horizontales Scrollen
            const parent = table.parentElement;
            if (parent && parent.classList.contains("table-responsive")) continue;

            const wrapper = document.createElement("div");
            wrapper.className = "table-responsive";

            table.parentNode.insertBefore(wrapper, table);
            wrapper.appendChild(table);
        }
    })();
</script>

{{ end }}
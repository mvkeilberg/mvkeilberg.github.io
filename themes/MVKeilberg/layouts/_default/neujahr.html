{{ define "content" }}

<style>
    .table-responsive {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        background: #fff;
        border-radius: 12px;
        box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
        margin: 1rem 0;
    }

    .table thead th {
        background-color: #f1f3f5;
        font-weight: 600;
        border-bottom: 0;
    }

    .table-responsive>table {
        width: max-content;
        min-width: 100%;
    }

    .table td,
    .table th {
        padding-left: 16px;
        padding-right: 16px;
    }

    .group-item:hover {
        background: rgba(13, 110, 253, 0.06);
        border-radius: 8px;
    }

    .group-item:focus {
        outline: 2px solid rgba(13, 110, 253, 0.35);
        border-radius: 8px;
    }
</style>

<div class="container pt-4 pb-5" id="silvester">
    <div class="row text-center">
        <div class="col-lg-10 mx-auto">
            <h1 class="fw-bold text-primary">{{ .Title }}</h1>
            <p class="lead text-muted">{{ .Params.description }}</p>
        </div>
    </div>

    <div class="row mt-5 align-items-start">
        <div class="col-lg-8">
            <div class="rounded-3 shadow-sm border" style="height: 65vh; min-height: 420px; overflow: hidden;">
                <div id="map" style="height: 100%; width: 100%;"></div>
            </div>
            <p class="text-muted mt-2 mb-0">Standortdaten werden live aktualisiert.</p>
        </div>

        <div class="col-lg-4 pt-4 pt-lg-0">
            <div class="p-3 rounded-3 shadow-sm border bg-white">
                <h3 class="fw-semibold text-secondary mb-2">Gruppen</h3>
                <div id="groupList" class="text-muted small">Keine aktuellen Daten verfügbar. Warte auf Daten …</div>
            </div>
        </div>
    </div>

    <div class="row pt-5">
        <div class="col-12">
            {{- .Content | safeHTML -}}
        </div>
    </div>
</div>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

<script>
    const API_URL = {{ .Params.location_api | default "/update" | printf "%q" | safeJS }};
    const POLL_MS = 5000;

    const CLUBHOUSE = [49.977298266144714, 9.255421284031236];
    const CLUBHOUSE_ZOOM = 15;

    const map = L.map("map").setView(CLUBHOUSE, CLUBHOUSE_ZOOM);

    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
        attribution: '&copy; OpenStreetMap-Mitwirkende'
    }).addTo(map);

    const markers = new Map();

    function escapeHtml(str) {
        return String(str || "")
            .replaceAll("&", "&amp;")
            .replaceAll("<", "&lt;")
            .replaceAll(">", "&gt;")
            .replaceAll('"', "&quot;")
            .replaceAll("'", "&#039;");
    }

    function fmtTime(tsSeconds) {
        try {
            const d = new Date(tsSeconds * 1000);
            return d.toLocaleTimeString("de-DE", {
                hour: "2-digit",
                minute: "2-digit",
                hour12: false
            });
        } catch {
            return "";
        }
    }

    const COLOR_ORDER = ["red", "blue", "green", "orange", "violet", "yellow", "grey", "black"];
    const ICON_BASE = "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/";

    const iconCache = new Map();

    function hashStringToInt(s) {
        let h = 0;
        for (let i = 0; i < s.length; i++) {
            h = ((h << 5) - h) + s.charCodeAt(i);
            h |= 0;
        }
        return Math.abs(h);
    }

    function colorForGroup(name) {
        const idx = hashStringToInt(name) % COLOR_ORDER.length;
        return COLOR_ORDER[idx];
    }

    function getIconForGroup(name) {
        if (iconCache.has(name)) return iconCache.get(name);

        const color = colorForGroup(name);
        const icon = new L.Icon({
            iconUrl: `${ICON_BASE}marker-icon-${color}.png`,
            shadowUrl: "https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png",
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
        });

        iconCache.set(name, icon);
        return icon;
    }

    function updateSidebar(groupsObj) {
        const el = document.getElementById("groupList");
        const names = Object.keys(groupsObj || {}).sort((a, b) => a.localeCompare(b, "de"));

        if (names.length === 0) {
            el.innerHTML = "Keine aktuellen Daten verfügbar. Warte auf Daten …";
            return;
        }

        el.innerHTML = names.map(name => {
            const g = groupsObj[name] || {};
            const t = g.ts ? fmtTime(g.ts) : "";
            const user = g.user ? `,${g.user}` : "";
            const color = colorForGroup(name);

            return `
                <div class="d-flex justify-content-between align-items-baseline py-1 group-item"
                     role="button"
                     tabindex="0"
                     data-group="${escapeHtml(name)}"
                     style="cursor:pointer;">
                    <span class="d-flex align-items-center gap-2">
                        <span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:${color};"></span>
                        <span>
                            <span class="fw-semibold text-primary">${escapeHtml(name)}</span>
                            <span class="text-muted">${escapeHtml(user)}</span>
                        </span>
                    </span>
                    <span class="text-muted">${escapeHtml(t)}</span>
                </div>
            `;
        }).join("");
    }

    const FOCUS_ZOOM = 17;

    function focusGroupByName(name) {
        const m = markers.get(name);
        if (!m) return;

        const ll = m.getLatLng();
        map.flyTo(ll, Math.max(map.getZoom(), FOCUS_ZOOM), { duration: 0.6 });
        m.openPopup();
    }

    document.getElementById("groupList").addEventListener("click", (e) => {
        const item = e.target.closest(".group-item");
        if (!item) return;
        const name = item.getAttribute("data-group");
        if (!name) return;
        focusGroupByName(name);
    });

    document.getElementById("groupList").addEventListener("keydown", (e) => {
        if (e.key !== "Enter" && e.key !== " ") return;
        const item = e.target.closest(".group-item");
        if (!item) return;
        e.preventDefault();
        const name = item.getAttribute("data-group");
        if (!name) return;
        focusGroupByName(name);
    });

    let lastGroupCount = 0;
    let hasSetInitialView = false;

    function setInitialOrAutoFit(groupLatLngs) {
        const count = groupLatLngs.length;

        if (count === 0) {
            map.setView(CLUBHOUSE, CLUBHOUSE_ZOOM);
            hasSetInitialView = true;
            lastGroupCount = 0;
            return;
        }

        if (count === 1) {
            const bounds = L.latLngBounds(groupLatLngs);
            map.fitBounds(bounds.pad(0.6));
            hasSetInitialView = true;
            lastGroupCount = 1;
            return;
        }

        if (count !== lastGroupCount || !hasSetInitialView) {
            const bounds = L.latLngBounds(groupLatLngs);
            map.fitBounds(bounds.pad(0.25));
            hasSetInitialView = true;
        }

        lastGroupCount = count;
    }

    async function fetchAndRender() {
        try {
            const res = await fetch(API_URL, { cache: "no-store" });

            if (res.status === 204) {
                updateSidebar({});
                for (const [name, m] of markers.entries()) {
                    map.removeLayer(m);
                    markers.delete(name);
                }
                setInitialOrAutoFit([]);
                return;
            }

            if (!res.ok) throw new Error("HTTP " + res.status);

            const data = await res.json();
            const groups = (data && data.groups) ? data.groups : {};

            updateSidebar(groups);

            const activeNames = new Set(Object.keys(groups));
            const latlngs = [];

            for (const name of Object.keys(groups)) {
                const g = groups[name] || {};
                const lat = Number(g.lat);
                const lon = Number(g.lon);
                if (!Number.isFinite(lat) || !Number.isFinite(lon)) continue;

                latlngs.push(L.latLng(lat, lon));

                const timeStr = g.ts ? fmtTime(g.ts) : "";
                const userStr = g.user ? g.user : "";

                const popupHtml = `
                    <div>
                        <div class="fw-semibold">${escapeHtml(name)}</div>
                        <div class="text-muted small">${lat.toFixed(6)}, ${lon.toFixed(6)}</div>
                        <div class="text-muted small">${escapeHtml(userStr)}${timeStr ? " • " + escapeHtml(timeStr) : ""}</div>
                        ${g.osm ? `<div class="mt-2"><a href="${g.osm}" target="_blank" rel="noopener">OpenStreetMap öffnen</a></div>` : ""}
                    </div>
                `;

                const icon = getIconForGroup(name);
                const pos = [lat, lon];

                if (!markers.has(name)) {
                    const m = L.marker(pos, { icon }).addTo(map);
                    m.bindPopup(popupHtml);
                    markers.set(name, m);
                } else {
                    const m = markers.get(name);
                    m.setLatLng(pos);
                    m.setIcon(icon);
                    m.setPopupContent(popupHtml);
                }
            }

            for (const [name, m] of markers.entries()) {
                if (!activeNames.has(name)) {
                    map.removeLayer(m);
                    markers.delete(name);
                }
            }

            setInitialOrAutoFit(latlngs);

        } catch (e) {
            console.log("fetchAndRender error:", e);
        }
    }

    fetchAndRender();
    setInterval(fetchAndRender, POLL_MS);
</script>

<script>
    (function () {
        const tables = document.querySelectorAll(".container table, main table, article table");

        for (const table of tables) {
            table.classList.add("table", "table-hover", "align-middle");
            table.classList.add("table-sm");

            for (const cell of table.querySelectorAll("th, td")) {
                cell.classList.add("text-nowrap");
            }

            const parent = table.parentElement;
            if (parent && parent.classList.contains("table-responsive")) continue;

            const wrapper = document.createElement("div");
            wrapper.className = "table-responsive";

            table.parentNode.insertBefore(wrapper, table);
            wrapper.appendChild(table);
        }
    })();
</script>

{{ end }}